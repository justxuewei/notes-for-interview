- [Operating System](#operating-system)
  - [程序执行过程](#程序执行过程)
    - [编译](#编译)
    - [链接](#链接)
    - [装入](#装入)
    - [逻辑地址和物理地址](#逻辑地址和物理地址)
  - [内存管理](#内存管理)
    - [内存管理的主要功能](#内存管理的主要功能)
    - [存储保护](#存储保护)
    - [内存扩充](#内存扩充)
    - [覆盖](#覆盖)
    - [交换](#交换)
      - [覆盖和交换区别](#覆盖和交换区别)
    - [内存分配](#内存分配)
      - [连续分配](#连续分配)
    - [非连续分配](#非连续分配)
      - [基本分页存储管理](#基本分页存储管理)
        - [地址变换机制及变化过程](#地址变换机制及变化过程)
    - [基本分段式存储管理](#基本分段式存储管理)
    - [分页与分段的区别](#分页与分段的区别)
    - [段页式管理方式](#段页式管理方式)
    - [虚拟内存](#虚拟内存)
      - [局部性原理](#局部性原理)
      - [概念](#概念)
      - [页面置换算法](#页面置换算法)
  - [进程与线程与协程](#进程与线程与协程)
    - [进程](#进程)
    - [线程](#线程)
    - [协程](#协程)
  - [区别](#区别)
  - [进程调度](#进程调度)
    - [批处理系统](#批处理系统)
      - [先来先服务 first-come first-serverd（FCFS）](#先来先服务-first-come-first-serverdfcfs)
      - [短作业优先 shortest job first（SJF）](#短作业优先-shortest-job-firstsjf)
      - [最短剩余时间优先 shortest remaining time next（SRTN）](#最短剩余时间优先-shortest-remaining-time-nextsrtn)
    - [交互式系统](#交互式系统)
      - [时间片轮转](#时间片轮转)
      - [优先级调度](#优先级调度)
      - [多级反馈队列](#多级反馈队列)
  - [进程同步](#进程同步)
  - [进程通信](#进程通信)

# Operating System

## 程序执行过程
### 编译

编译：由编译程序将用户源代码编译成若干个目标模块
### 链接

链接：由链接程序将变以后的模块和所需要的库函数连接在一起，形成一个完整的装入模块
程序链接的三种方式：
静态链接：在程序运行之前，就将所有模块和库函数的连在一起不再分开。
装入时动态链接：将用户编译后的一组模块在装入内存的时候，边链接边装入。
运行时动态链接：在运行程序执行中需要哪些模块才将其连接装入，便于修改与更新。
### 装入

装入：由装入程序将装入模块装入内存运行
装入的三种方式：
绝对装入：程序编译的时候如果已经知道要将目标模块放在内存中的哪一个位置，由于程序的逻辑地址与物理地址相同，所以直接装入
可重定位装入：在多道程序环境下，多个目标模块逻辑地址的起始地址都是从0开始的，装入是对程序中的逻辑地址进行修改从而得到物理地址。比如：一个模块分配的地址在内存中是从100开始的，此时它里面标号为69的逻辑地址实际上是169。
动态运行时装入：装入程序版装入模块装入内存后，并不立即把装入模块中的地址转换为绝对地址，而是推迟到程序要执行的时候才进行转换，一次装入内存后都为相对地址。

### 逻辑地址和物理地址

编译器将程序代码分成若干个模块，每个目标模块都从0号单元开始编址，这就是该目标模块的相对地址(逻辑地址)；当每个目标模块链接成一个完整的可执行目标程序的时候，连接程序会依稀按照各个模块的相对地址统一构成从0号单元开始编址的绝对地址(物理地址)

## 内存管理

### 内存管理的主要功能
内存的分配与回收：当作业或进程创建后系统会为他们分配内存空间，当结束后内存空间也会被回收。

地址转换：将程序中的逻辑地址转换成内存中的物理地址

内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存

存储保护：保证个个作业在自己的内存空间内运行，互不干扰

### 存储保护
概念：在分配内存的时候，为了保证操作系统不受进程的影响，同时保证进程之间互不干扰，从而引出了内存保护。
方法：
在CPU中设置一堆上下限寄存器，存放用户作业在主存中的上限地址与下限地址。当CPU要访问内存的时候，分别用这两个地址和要访问的地址做比较。
重定位寄存器(基址寄存器)和界地址寄存器(限长寄存器)。重定位寄存器存储改作业的物理地址最小值；界地址寄存器存储改作业逻辑地址最大值。当CPU要访问内存的时候，分别用这两个地址数值之和与要访问的地址做比较。

### 内存扩充

### 覆盖
由于程序在运行的时候并不是任何时候都要访问程序的所有数据和代码，所以可以将用户空间分成一个固定区和如若干个覆盖区。将经常使用的程序段放在固定区(不会被调出)。而那些互斥使用的程序可以交替使用覆盖区，如果不使用的话，会被调出内存。

### 交换
把处于等待状态的进程从内存移到辅村，内存空间腾出来，这个叫做换出；把将要调用的进程在从辅村调到内存，这个过程叫做换入。

#### 覆盖和交换区别
覆盖是在同一个程序或者进程之间的
交换是在不同进程和程序之间的
所以覆盖技术与交换技术可以一起使用

### 内存分配

#### 连续分配
略

### 非连续分配

可以将一个进程分散的装入内存分区。根据分区的大小是否固定可以分成分页存储管理(固定)与分段存储管理(不固定)，为了避免两者的缺点，还可以二者混用成段页式存储管理。再根据进程运行作业时是否将作业的的全部代码装入内存，又分为基本分页存储管理(全部装入内存)和请求分页存储管理(非一次全装入内存)。

#### 基本分页存储管理

思想：把主存空间划分为大小相等的块，块相对较小，作为主存的基本单元。每个进程也以块为单位划分，进程执行时，以块为单位申请内存空间
概念：
块：外存中的块
页(页面)：进程里面的块
页框(页帧)：内存中的块
地址结构：地址结构包含两部分，第一部分是页号(P)，根据页号的位数可以算出地址结构可容纳最大页数；第二部分是页内偏移量(W)，可以计算出页面的大小。地址结构决定了虚拟内存的寻址空间有多大(页面的总数，比如P有二十位，那么地址空间最多有$2^{20}$个页面)。
页表：为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录每个页面(进程中的块)在内存中的物理块号，一般放在内存中。页表项由两部分构成，第一部分存储页号，第二部分储存物理内存中的块号。
注意：进程中的块的各个代码，在内存中对应的物理地址是=页表中物理内存块号+地址结构中页内偏移量

##### 地址变换机制及变化过程

概念：主要用于将逻辑地址转换成内存中的物理地址。借助于页表来实现的。

![](https://pic3.zhimg.com/80/v2-f9ed96955853db915fcf54ea1664c63e_1440w.jpg)

步骤：

1、在系统中会设置一个页表寄存器(PTR)，用来储存页表在内存中的起始地址Ｆ和页表长度M

2、根据逻辑地址计算出页号和业内偏移量

3、判断页号是否越界

4、查询页表找到页号对应的页表项，确定页面的内存块号(第一次访存，因为页表在内存中)

5、用内存块号和业内偏移量的到物理地址

6、访问内存目标单元(第二次访存)

问题：(1)每次访问内存都需要地址转换(逻辑地址->物理地址)，浪费时间；(2) 内存中快表不能占有太大的内存，不然降低了内存利用率。

### 基本分段式存储管理

分页存储是从计算机的角度设计的，目的是为了提高内存的利用率，提升计算机的性能。分段存储的提出是考虑到程序员和用户，以满足方编程、数据共享、信息保护、动态增长、动态链接的需要。

基本概念

分段：按照进程自然划分炒年成逻辑空间，例如进程由主程序、两个子程序、栈和数据组成。于是可以把这个进程分成5段，每一段的逻辑地址从0开始编址，并分配一段连续的内存空间。(注意这里段内必须连续，段与段之间可以分散)
逻辑地址结构：是由两部分组成第一部分为段号S，看进程是哪一个段，段号的位数决定了进程分了多少段；第二部分为段内偏移量W，段内偏移量决定了这段进程的最大长度。
段表：每个进程都以一张逻辑空间与内存空间映射的段表，每个段表对应进程的一段，段表项季度该段在内存中的起始地址和长度。段表由三个部分组成：段号、段长、本段在主存中的起始地址(基址)。

![](https://pic1.zhimg.com/80/v2-3caade5f79544e0303d88df566886558_1440w.jpg)

进切换内核程序回复进程的运行环境，从PCB中找到段表寄存器
根据逻辑地址得到段号、段内地址
将段号与段表长度比较，判断段号是否越界，产生越界中断

查询段表，找到对应的段表项，段表项存放的地址为段表起始地址+段号*段表项长度(因为为了节省内存空间，可以参略段表中的段号，那么计算段表项的起始地址就可以用这种方法)
对段内地址W进行检查，是否超过段长。如果超越就产生中断

根据段的基址和和段内地址得到物理地址
访问目标内存单元

### 分页与分段的区别

1、页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存的利用率。分页仅仅是系统管理上的需求，安全是系统行为对用户是不可见的 段是信息的逻辑单位，分段的主要目的是更好地满足用户需求，一个段通常包含一组数语一个逻辑板块的信息。分段是用户可见的，用户编程时需要显示的给出段名。

2、页的大小是固定的，系统决定；段的大小是不固定的，取决于系统程序

3、分页的用户地址空间是一维的，程序员只需要给出一个记忆符就可以表示一个地址 分段存储管理的地址空间是二维的，程序员需要在标识一个地址的时候，既要给出段名，也要给出段内地址

4、分段比分页更容易实现信息的共享和保护 注意：不能修改的代码称为纯代码(可重入代码)，这样的代码段不是临界资源，可以共享。可修改的代码是不可以共享的（比如由很多变量的代码段） 比如：生产者进程的一个进程段，是用来判断该缓冲区此时是否可以访问，这个时候消费者进程的段表项也可以指向这里 为什么分业管理不方便实现代码共享？ 因为将生产者进程分段，由于页面的空间有限，一段可能被装入多个空间，一个空间也可能有多个代码段被装进来，所以适合共享，达不到安全的效果

5、访问一个逻辑地址需要几次访问内存？ 单级页表：1.查内存中的页表——2.访问目标内存单元 分段：1.查询内存中的段——2.访问目标内存单元 分段与分页系统相似，分段系统也可以引入快表机构，将近期访问过的段表放到快表中，这样可以少一次访问，加快地址变换速度

6、分页：内存空间利用率高，不会产生外部碎片，只有少量的内部碎片；不方便按照逻辑模块实现信息的共享与保护 分段：方便按照逻辑模块实现信息的共享与保护；如果段太长，为其分配很大的存储空间很不方便，容易产生外部碎片（这个虽然可以用前面的一些紧凑技术解决一部分，但是时间代价很大）

### 段页式管理方式
首先将进程根据逻辑结构划分成若干个逻辑段，每个段都有自己的段号，然后将这些段划分成若干个大小固定的页。这样对内存空间的管理依然和分页式管理相似，将内存分成和页面大小相同的存储块，对内存分配一存储块为单位。
逻辑地址结构：逻辑地址结构由段号S(决定每个进程的段数)、页号P(决定每段的页数)、页内偏移量W(页面的大小和内存块的大小)组成。

### 虚拟内存

#### 局部性原理

局部性原理分为时间局部性与空间局部性。 时间局部性：程序中的一条指令一旦执行，不久后改指令还可能再次被执行。产生时间局部性的原因是程序中存在大量的循环操作。 空间局部性：一旦程序访问了某个存储单元，在不久后，其附近的存储单元也会被访问。因为指令的顺序通常是顺序存储、顺序执行的。数据的存储也是向量、数组、表等形式

#### 概念

基于局部性原理，在程序装入内存时，只会将程序的一部分装入内存，就可以启动程序。在程序执行过程中如果所需要的信息不在内存中，可以由操纵系统将需要的那一部分数据再调入内存。如果操作系统暂时不适用某些内容，可以将其调到外存上，从而腾出空间供别的作业使用。以上就称为虚拟存储器。


虚拟内存的实现需要建立在离散分配的内存管理方式上 主要实现方式：

请求分页存储管理
请求分段存储管理
请求段页式存储管理
硬件支持：
一定的内存与外存空间
页表机制或者段表机制
中断机制，当用户要访问的程序调入内存需要中断
地址变换机制，逻辑地址转换成物理地址

![](https://pic3.zhimg.com/80/v2-a48b7b7d713c291720fad6bfe8e46a26_1440w.jpg)

#### 页面置换算法

页面置换算法主要是决哪一页被换入，哪一页被换出。

最佳置换算法(OPT)

思想：最佳置换算法是淘汰以后不会使用的，或者是在长时间内不在访问的页面，以保证获得最低的缺页率。
特点：这个算法是很难实现的，由于很难预估那个页面是以后不会访问的。
注意：最长时间不访问和以后访问次数最小是两个概念。
先进先出页面置换算法(FIFO)

思想：淘汰最早进入内存的页面，就是在内存中驻留最久的页面。
特点：这个算法容易实现，但是不符合常理，因为在进程中有的页面会被经常访问到。
注意：这个算法可能产生换页次数不减反增的现象，称为Belady现象
最近最久未使用置换算法(LRU)

思想：选择最近最长时间没有被访问的页面
特点：性能好，但是需要寄存器和栈的硬件支持，
时钟置换算法(CLOCK)

简单的时钟置换算法
思想：让一个指针循环扫描缓冲区，像时钟转动一样。会给每一页面增加一个附加位，称为使用位。当页面被调入内存的时候和页面被使用后将他的使用位置为1。页面需要替换的时候，指针会扫描每一页的使用位，如果为1，扫描过后置成0；如果为0，就将该页置换出去。如果所有的页面都为1的话，会继续扫描第二遍。
特点：这个算法的思想其实和最近最久未使用页面置换算法相似，只是这个实现起来更加的方便。

## 进程与线程与协程

### 进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

### 线程
线程是指进程内的一个执行单元,也是进程内的可调度实体。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

### 协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。


## 区别
Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 进程调度

### 批处理系统

#### 先来先服务 first-come first-serverd（FCFS）

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

#### 短作业优先 shortest job first（SJF）

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#### 最短剩余时间优先 shortest remaining time next（SRTN）

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 交互式系统

#### 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
而如果时间片过长，那么实时性就不能得到保证。


#### 优先级调度

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 多级反馈队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

## 进程同步

临界区

对临界资源进行访问的那段代码称为临界区。
为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

同步与互斥

同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。

互斥：多个进程在同一时刻只有一个进程能进入临界区。


信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；

up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。

管程

在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

## 进程通信
进程同步与进程通信很容易混淆，它们的区别在于：

进程同步：控制多个进程按一定顺序执行；
进程通信：进程间传输信息。
进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

1. 管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。
```C
#include <unistd.h>
int pipe(int fd[2]);
```
它具有以下限制：

只支持半双工通信（单向交替传输）；

只能在父子进程或者兄弟进程中使用。

![](https://camo.githubusercontent.com/af6ac5de61c835b0fe14c799c244632fa04239ef2ca9421eee543392353297c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35336364396164652d623061362d343339392d623464652d3766316662643036636466622e706e67)

2. FIFO
   
也称为命名管道，去除了管道只能在父子进程中使用的限制。

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

![](https://camo.githubusercontent.com/8c4dd36cf4d1509b9c3ae0500085617fee811f7a83602a71e64769753b66b66b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32616335306238312d643932612d343430312d623965632d6632313133656363333037362e706e67)





 












